We start the exercise by defining the difference between **managed state** and **derived state**

* **Managed State**: State that you need to explicitly manage
* **Derived State**: State that you can calculate based on other state

In this exercise plenty of the hard calculations are done from the fn already in place so is more a refresher on [[React.useState()|useState]] than a deep dive because all you have to do is simply follow the instruction and create the managed state.

All the derived state is done in the fns `calculateNextValue`, `calculateWinner` and `calculateStatus` and we call it **derived state** because we pass in them our state but we do not use any [[React.useState()|useState]] Hooks in them an neither the setter function for our state.

The *Extra Credit 1/2* is something that we've already seen in [[1. useState greeting|the first workshop]] so I do not bother to describe them here.

### Extra Credit 3
In this exercise we want to create an history of the game, that means that we want to record each action players have made during the game and add the ability to move between those steps.

The first thing we need to do is [[3. Lifting state|lift the state]] so we can share it between the `Board` component and he parent `Game` one. In order to do so we replace the current definition of the `Game` component:
```js
function Game() {
  return (
    <div className="game">
      <div className="game-board">
        <Board />
      </div>
    </div>
  )
}
```
With the new one that uses the state:
```js
function Game() {
	return (
		<div className="game">
		  <div className="game-board">
			<Board onClick={selectSquare} squares={currentSquares} />
			<button className="restart" onClick={restart}>
			  restart
			</button>
		  </div>
		  <div className="game-info">
			<div>{status}</div>
			<ol>{moves}</ol>
		  </div>
		</div>
	  )	  
}
```
Now we render `Board` passing the click handler via `onClick` prop and we pass the `currentSquares` state via the `squares` prop. Also the `Game` is responsible to show the reset button and to show the lists of moves inside the `.game-info` element.

We need to refactor the state because we do not keep track anymore of a single array (the board) but we need to keep track of all the boards for the game, so we need an array of arrays.

We do so creating two new states:
* **history** - this will keep track of all the boards and its index will let us time-travel between states
* **currentStep** - defines the steps we're in

```js
const [ history, setHistory ] = React.useState([Array(9).fill(null)]);
const [ currentStep, setCurrentStep ] = React.useState(0);
```
We use both of them to find out the `currentSquare` that will be used to calculate `nextValue`, `winner` and the `status`:
```js
const currentSquares = history[currentStep];
```

The main work that we need to do is based on the `selectSquare` fn because now we need to insert the new array generated by the board as the last one in `history`, before was easier because all we had to do was to replace the whole array.
```js
function selectSquare(square) {
	if( winner || currentSquares[square] ){
		return;
	}
	const newHistory = history.slice(0, currentStep + 1);
	const squaresCopy = [...currentSquares];
	squaresCopy[square] = nextValue;
	setHistory([...newHistory, squaresCopy])
	setCurrentStep(newHistory.length);
}
```
One of the most interesting parts of this is the definition of `newHistory`, we use the [[Array.prototype.slice()|slice]] method because we do not care about the following steps. This is especially useful when a user time-travel backwards since we will replace the following steps with the new one.